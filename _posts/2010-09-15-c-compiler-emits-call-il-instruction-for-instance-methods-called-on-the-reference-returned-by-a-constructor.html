---
layout: post
title: C# Compiler Emits call IL Instruction for Instance Methods Called on the Reference
  Returned by a Constructor
date: 2010-09-15 14:34:01.000000000 +02:00
categories: []
tags:
- C#
- IL
status: publish
type: post
published: true
meta: {}
author:
  login: admin
  email: pvlerick@gmail.com
  display_name: Philippe
  first_name: Philippe
  last_name: Vlérick
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Some time ago, I wrote how the call instruction could actually call an instance method on a null reference, and that inside this instance method, the <strong>this</strong> keyword would reference to <strong>null</strong>.</p>
<p>I find that very interesting, so I kept on disassembling some sample code to see what’s the generated IL and try to grasp some of the compiler’s logic.</p>
<p>Here is some simple code used to see what’s the IL generated by the C# compiler:</p>
<pre class="code"><span style="color: blue">class </span><span style="color: #2b91af">Hello1
</span>{
    <span style="color: blue">internal </span><span style="color: #2b91af">String </span>GetHello()
    {
        <span style="color: blue">return </span><span style="color: #a31515">&quot;Hello1&quot;</span>;
    }
}

<span style="color: blue">sealed class </span><span style="color: #2b91af">Hello2
</span>{
    <span style="color: blue">internal </span><span style="color: #2b91af">String </span>GetHello()
    {
        <span style="color: blue">return </span><span style="color: #a31515">&quot;Hello2&quot;</span>;
    }
}

<span style="color: blue">static void </span>Main(<span style="color: blue">string</span>[] args)
{
    <span style="color: blue">var </span>h1 = <span style="color: blue">new </span><span style="color: #2b91af">Hello1</span>();
    <span style="color: #2b91af">Console</span>.WriteLine(h1.GetHello());

    <span style="color: blue">var </span>h2 = <span style="color: blue">new </span><span style="color: #2b91af">Hello2</span>();
    <span style="color: #2b91af">Console</span>.WriteLine(h2.GetHello());

    <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: blue">new </span><span style="color: #2b91af">Hello1</span>().GetHello());

    <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: blue">new </span><span style="color: #2b91af">Hello2</span>().GetHello());

    <span style="color: #2b91af">Console</span>.ReadLine();
}</pre>
<p>In the first two calls, we use a local variable that we call the <em>GetHello</em> method on, and in the two last calls we instantiate the object and call the <em>GetHello</em> method on the reference returned by the constructor, reference that we don’t keep.</p>
<p>Here’s the IL generated for the <em>Main</em> method:</p>
<p><a href="/assets/CallCallvirtIL_thumb.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="CallCallvirtIL" border="0" alt="CallCallvirtIL" src="/assets/CallCallvirtIL_thumb.png" width="396" height="488" /></a></p>
<p>We can see that in the first two call, the <strong>callvirt</strong> instruction is emitted by the compiler. As the call happens on a variable, the runtime type of the object could be different from the compile type, meaning that using the <strong>callvirt</strong> instruction makes sense (the compiler is not “smart” enough to detect that the compile time and the runtime types are the same).</p>
<p>In the two subsequent calls, however, as the method call is done on the reference returned by the constructor, the instruction emitted is <strong>call</strong>, which is slightly more performant than <strong>callvirt</strong>.</p>
<p>For more information on <strong>call</strong> and <strong>callvirt</strong> instructions, see ECMA 335 12.4.1.2.</p>
